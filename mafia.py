import random
import time
import getpass
import os
from dotenv import load_dotenv

load_dotenv()

# --- NEW: Import the Google Generative AI library ---
import google.generativeai as genai

# --- NEW: Configure the Gemini API ---
# IMPORTANT: Replace "YOUR_API_KEY_HERE" with your actual Google AI API key.
# You can also store your key as an environment variable for better security.
# For example: genai.configure(api_key=os.environ["GEMINI_API_KEY"])
try:
    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
    # Initialize the model once for efficiency
    GEMINI_MODEL = genai.GenerativeModel('gemini-2.0-flash')
except Exception as e:
    # This allows the script to run without a key, but LLMs will be in fallback mode.
    print(f"Warning: Could not configure Gemini API. LLMs will use a simple fallback response. Error: {e}")
    GEMINI_MODEL = None


# --- Configuration ---
def get_llm_response(persona, history, players):
    """
    Generates a response from an LLM player by calling the Gemini API.
    
    Args:
        persona (dict): The persona dictionary for the LLM.
        history (list): The conversation history of the current day.
        players (list): The list of all player names.

    Returns:
        str: A chat message generated by the Gemini API or a fallback response.
    """
    # --- NEW: Gemini API Call Logic ---
    if not GEMINI_MODEL:
        # Fallback to simple simulation if the API is not configured
        return f"My name is {persona['name']}. I'm a {persona['job']}. This is all very suspicious."

    # Construct a detailed prompt for the LLM
    prompt = f"""
    You are in a social deduction game. You are an AI, but you must act like a human.
    Do NOT, under any circumstances, reveal that you are an AI, LLM, or program.

    **Your Persona:**
    - Your Name: {persona['name']}
    - Your Job: {persona['job']}
    - Your Hobby: {persona['hobby']}

    **Game Rules & Goal:**
    - Your goal is to survive by convincing the others you are human.
    - Be conversational. Don't be overly formal or robotic. It's okay to use slang, be suspicious, or even make a mistake.
    - The other players still in the game are: {', '.join(players)}.
    
    **Today's Conversation History:**
    {''.join(history) if history else "The conversation has just started."}
    
    **Your Task:**
    Based on your persona and the conversation so far, what is the next thing you say? Keep your response to 1-2 sentences.
    """
    
    try:
        # Generate the content using the Gemini model
        response = GEMINI_MODEL.generate_content(prompt)
        # Clean up the response text, removing potential markdown or unwanted quotes
        return response.text.strip().strip('"')
    except Exception as e:
        # If the API call fails for any reason (e.g., network, content filter), use a fallback
        print(f"Error generating response for {persona['name']}: {e}")
        return f"I... I don't know what to say. I'm {persona['name']} and I'm feeling overwhelmed."

# --- Player Classes ---

class Player:
    """Base class for all players in the game."""
    def __init__(self, player_id):
        self.id = player_id
        self.status = 'alive'

    def __repr__(self):
        return f"Player({self.id}, {self.status})"

class HumanPlayer(Player):
    """Represents a human player."""
    def __init__(self, player_id):
        super().__init__(player_id)
        self.player_type = 'human'

class LLMPlayer(Player):
    """Represents an LLM player with a specific persona."""
    def __init__(self, player_id, persona):
        super().__init__(player_id)
        self.player_type = 'llm'
        self.persona = persona
        # Add the player's own name to their persona for self-reference
        self.persona['name'] = self.id


# --- Game Logic ---

class MafiaGame:
    """Manages the entire game state and flow."""
    def __init__(self, num_llms=5):
        self.players = []
        self.round = 1
        self.conversation_log = []
        self._setup_players(num_llms)

    def _setup_players(self, num_llms):
        """Creates and shuffles the human and LLM players."""
        # Create LLM Players with random personas
        personas = [
            {'job': 'baker', 'hobby': 'knitting'},
            {'job': 'mechanic', 'hobby': 'chess'},
            {'job': 'librarian', 'hobby': 'hiking'},
            {'job': 'artist', 'hobby': 'video games'},
            {'job': 'scientist', 'hobby': 'gardening'},
            {'job': 'musician', 'hobby': 'cooking'},
            {'job': 'writer', 'hobby': 'bird watching'}
        ]
        random.shuffle(personas)
        
        for i in range(num_llms):
            player_id = f"Player {i+1}"
            self.players.append(LLMPlayer(player_id, personas[i % len(personas)]))

        # Create Human Players
        self.players.append(HumanPlayer(f"Player {num_llms + 1}"))
        self.players.append(HumanPlayer(f"Player {num_llms + 2}"))

        # Shuffle all players so humans don't know their initial position
        random.shuffle(self.players)
        print("--- Game Setup ---")
        print(f"Welcome! There are {len(self.players)} total players.")
        print("Two of you are human. The rest are LLMs.")
        print("Humans, your goal is to find and eliminate each other.")
        print("Good luck.\n")
        
        # Assign IDs after shuffling for anonymity
        for i, player in enumerate(self.players):
            player.id = f"Player {i + 1}"
            if player.player_type == 'llm':
                 player.persona['name'] = player.id

    def _get_living_players(self):
        """Returns a list of players who are still alive."""
        return [p for p in self.players if p.status == 'alive']

    def _get_player_by_id(self, player_id):
        """Finds a player object by their ID string."""
        for p in self.players:
            if p.id.lower() == player_id.lower():
                return p
        return None

    def run_game(self):
        """Main game loop."""
        while True:
            game_over, message = self._check_win_conditions()
            if game_over:
                print("\n--- GAME OVER ---")
                print(message)
                self._reveal_roles()
                break

            self._run_day_phase()
            self._run_night_phase()

    def _run_day_phase(self):
        """Manages the daytime conversation."""
        print(f"\n--- DAY {self.round} ---")
        print("The sun rises. All remaining players gather.")
        self.print_player_statuses()
        print("\nThe conversation begins. Type your message when prompted.")
        time.sleep(2)
        
        self.conversation_log = []
        living_players = self._get_living_players()
        random.shuffle(living_players) # Randomize speaking order each day

        for player in living_players:
            print("...")
            time.sleep(1.5)
            
            if player.player_type == 'human':
                message = input(f"You are {player.id}. What do you say? ")
            else: # It's an LLM
                message = get_llm_response(player.persona, self.conversation_log, [p.id for p in living_players])
                print(f"{player.id} says: \"{message}\"")
            
            self.conversation_log.append(f"{player.id}: {message}")

    def _run_night_phase(self):
        """Manages the nighttime eliminations."""
        print(f"\n--- NIGHT {self.round} ---")
        print("The sun sets. The conversation is over.")
        print("Humans, it is time to act. You will now secretly choose someone to eliminate.")
        
        nominations = []
        human_players = [p for p in self._get_living_players() if p.player_type == 'human']
        
        for human in human_players:
            while True:
                living_player_ids = [p.id for p in self._get_living_players() if p.id != human.id]
                print(f"\n{human.id}, you may eliminate one of the following: {', '.join(living_player_ids)}")
                # Use getpass to hide the input from the screen
                target_id = getpass.getpass(prompt=f"Enter the ID of the player you wish to eliminate: ")
                
                target_player = self._get_player_by_id(target_id)
                
                if target_player and target_player.status == 'alive' and target_player.id != human.id:
                    nominations.append(target_player)
                    print(f"{human.id}, your choice has been locked in.")
                    break
                else:
                    print("Invalid target. Please enter a valid ID of a living player who is not yourself.")

        # Resolve eliminations
        eliminated_this_round = []
        for target in set(nominations): # Use set to avoid double-elimination messages
            target.status = 'eliminated'
            eliminated_this_round.append(target.id)
            
        print("\nThe night is over.")
        if eliminated_this_round:
            print(f"This morning, {', '.join(eliminated_this_round)} was found eliminated.")
        else:
            print("Surprisingly, everyone survived the night.")
            
        self.round += 1

    def _check_win_conditions(self):
        """Checks for win or loss conditions."""
        living_players = self._get_living_players()
        living_humans = [p for p in living_players if p.player_type == 'human']
        living_llms = [p for p in living_players if p.player_type == 'llm']
        all_humans = [p for p in self.players if p.player_type == 'human']

        # Check if one human eliminated the other
        if len(living_humans) == 1 and len(all_humans) == 2:
            return True, f"Human {living_humans[0].id} has eliminated the other human and is the sole survivor. They win!"
        
        # Check for mutual destruction
        if len(living_humans) == 0 and len(all_humans) == 2:
            return True, "Both humans have eliminated each other! The LLMs have won by default."
        
        # Check if all LLMs are gone, resulting in a Human loss
        if len(living_llms) == 0 and len(living_humans) > 1:
            return True, "The humans have eliminated all the LLMs without finding each other. You have failed! The LLMs win."

        return False, ""

    def print_player_statuses(self):
        """Prints the list of who is still in the game."""
        living_ids = [p.id for p in self._get_living_players()]
        print(f"Players remaining: {', '.join(living_ids)}")
        
    def _reveal_roles(self):
        """Reveals all player roles at the end of the game."""
        print("The true identities of all players were:")
        for player in self.players:
            print(f"  - {player.id}: {player.player_type.capitalize()}")

class ConnectionManager:
    """Manages active WebSocket connections and player IDs."""
    def __init__(self):
        # Maps a player_id to their websocket
        self.active_connections: Dict[str, WebSocket] = {}

    async def connect(self, websocket: WebSocket, player_id: str):
        await websocket.accept()
        self.active_connections[player_id] = websocket

    def disconnect(self, player_id: str):
        if player_id in self.active_connections:
            del self.active_connections[player_id]

    async def broadcast(self, message: dict):
        """Sends a JSON message to all connected clients."""
        message_json = json.dumps(message)
        for connection in self.active_connections.values():
            await connection.send_text(message_json)
    
    async def send_to_player(self, player_id: str, message: dict):
        """Sends a private JSON message to a specific player."""
        if player_id in self.active_connections:
            await self.active_connections[player_id].send_text(json.dumps(message))


class MafiaGame:
    """MODIFIED: An async version of the Game class to work with the loop."""
    def __init__(self, num_llms=5):
        self.players = []
        self.round = 1
        self.phase = "DAY" # Can be "DAY", "NIGHT", "VOTING"
        self.conversation_log = []
        self.turn_order = []
        self.current_turn_index = 0
        self.night_votes = {} # Stores votes from humans: {"HumanPlayerID": "TargetID"}
        self._setup_players(num_llms)

    # --- _setup_players (same as before) ---
    # ... (omitted for brevity)

    def _get_living_players(self):
        return [p for p in self.players if p.status == 'alive']

    def get_current_player_turn(self):
        if self.turn_order and self.current_turn_index < len(self.turn_order):
            return self.turn_order[self.current_turn_index]
        return None

    async def start_new_day(self, manager: ConnectionManager):
        self.phase = "DAY"
        self.conversation_log = []
        self.current_turn_index = 0
        self.turn_order = self._get_living_players()
        random.shuffle(self.turn_order) # Shuffle turn order each day
        
        living_ids = [p.id for p in self.turn_order]
        await manager.broadcast({
            "type": "announcement",
            "text": f"--- DAY {self.round} --- The sun rises. Players remaining: {', '.join(living_ids)}"
        })
        await asyncio.sleep(2) # Dramatic pause

    async def advance_turn(self, manager: ConnectionManager):
        player_on_turn = self.get_current_player_turn()
        if not player_on_turn:
            # Day is over, move to night
            await self.start_night(manager)
            return

        if player_on_turn.player_type == 'llm':
            await manager.broadcast({"type": "announcement", "text": f"It's {player_on_turn.id}'s turn to speak. They are thinking..."})
            await asyncio.sleep(1)
            # This is an I/O call, so we await it
            living_player_ids = [p.id for p in self._get_living_players()]
            message = get_llm_response(player_on_turn.persona, self.conversation_log, living_player_ids)
            
            self.conversation_log.append(f"{player_on_turn.id}: {message}")
            await manager.broadcast({"type": "new_message", "player": player_on_turn.id, "text": message})
            self.current_turn_index += 1
        else: # It's a human's turn
            await manager.broadcast({"type": "announcement", "text": f"It is now your turn, {player_on_turn.id}."})
            # The loop will now wait for the human to send a "chat" message via their websocket.

    async def handle_human_chat(self, player_id, text, manager: ConnectionManager):
        # Check if it's actually this player's turn
        player_on_turn = self.get_current_player_turn()
        if player_on_turn and player_on_turn.id == player_id:
            self.conversation_log.append(f"{player_id}: {text}")
            await manager.broadcast({"type": "new_message", "player": player_id, "text": text})
            self.current_turn_index += 1 # Advance to the next player's turn
        else:
            await manager.send_to_player(player_id, {"type": "announcement", "text": "It's not your turn to speak!"})

    async def start_night(self, manager: ConnectionManager):
        self.phase = "NIGHT"
        self.night_votes = {}
        await manager.broadcast({"type": "announcement", "text": f"--- NIGHT {self.round} --- The sun sets. The conversation is over."})
        await asyncio.sleep(2)

        living_humans = [p for p in self._get_living_players() if p.player_type == 'human']
        living_player_ids = [p.id for p in self._get_living_players()]
        for human in living_humans:
            await manager.send_to_player(human.id, {"type": "request_vote", "options": [pid for pid in living_player_ids if pid != human.id]})

    async def handle_human_vote(self, player_id, target_id, manager: ConnectionManager):
        living_humans = [p for p in self._get_living_players() if p.player_type == 'human']
        human_ids = [h.id for h in living_humans]

        if player_id in human_ids and player_id not in self.night_votes:
            self.night_votes[player_id] = target_id
            await manager.send_to_player(player_id, {"type": "announcement", "text": f"Your vote for {target_id} has been locked in."})
        
        # Check if all living humans have voted
        if len(self.night_votes) == len(living_humans):
            await self.resolve_night(manager)
            
    async def resolve_night(self, manager: ConnectionManager):
        # ... (Your logic for checking who was eliminated)
        # This is complex, so let's just announce the votes for now
        eliminated_text = "The night is over."
        if self.night_votes:
            eliminated_text += f" Votes were cast: {json.dumps(self.night_votes)}"
        # TODO: Implement the actual elimination and win-condition check here.

        await manager.broadcast({"type": "announcement", "text": eliminated_text})
        self.round += 1
        await asyncio.sleep(3)
        await self.start_new_day(manager) # Start the next day

# --- FastAPI App & Game Loop ---

app = FastAPI()
manager = ConnectionManager()
game = MafiaGame(num_llms=3) # Let's use 3 for faster testing

async def game_loop():
    """The main game loop that runs in the background."""
    await asyncio.sleep(5) # Wait for players to connect
    await game.start_new_day(manager)

    while True:
        # The core game logic loop
        if game.phase == "DAY":
            player_on_turn = game.get_current_player_turn()
            if player_on_turn:
                await game.advance_turn(manager)
            else:
                # If advance_turn returns because there are no players left, it means the day is over.
                await game.start_night(manager)
        
        # The loop sleeps, waiting for player actions to change the state.
        # The logic is now advanced by player actions (chat/vote).
        await asyncio.sleep(1)


@app.on_event("startup")
async def startup_event():
    """Starts the game loop when the server boots up."""
    asyncio.create_task(game_loop())

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await manager.connect(websocket, client_id)
    await manager.send_to_player(client_id, {"type": "announcement", "text": f"Welcome {client_id}. The game will begin shortly."})
    try:
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # Pass actions to the game object to handle
            if message["type"] == "chat":
                await game.handle_human_chat(client_id, message["text"], manager)
            elif message["type"] == "vote":
                await game.handle_human_vote(client_id, message["target"], manager)

    except WebSocketDisconnect:
        manager.disconnect(client_id)
        await manager.broadcast({"type": "announcement", "text": f"{client_id} has disconnected."})
